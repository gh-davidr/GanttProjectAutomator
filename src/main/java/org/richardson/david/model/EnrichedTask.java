/*
Copyright 2021 David Richardson, a regular GanttProject User

This file is part of GanttProjectAutomator, a utility conceived from
years of project management experience to make task status communication
just a little bit easier.

It works specifically with files generated by GanttProject, an 
open source project management tool.

GanttProjectAutomator is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

GanttProjectAutomator is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

See <http://www.gnu.org/licenses/>.
 */
package org.richardson.david.model;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.InternetAddress;

import org.richardson.david.config.UserConfig;
import org.richardson.david.entity.gantt.Allocation;
import org.richardson.david.entity.gantt.Depend;
import org.richardson.david.entity.gantt.Resource;
import org.richardson.david.entity.gantt.Task;
import org.richardson.david.utils.AppUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public class EnrichedTask 
{
	private static Logger LOGGER = LoggerFactory.getLogger(EnrichedTask.class);
	private static final SimpleDateFormat SD_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");

	private static HashMap<String, EnrichedTask> SUMMARISED_TASK_HASHMAP = new HashMap<>();

	@NonNull private Task task;

	@Getter(lazy=true) private final ArrayList<Resource> resources = initResources();	
	@Getter(lazy=true) private final ArrayList<EnrichedDepend> enrichedDepends = initEnrichedDepends();	
	@Getter(lazy=true) private final HashMap<String, Resource> resourceHashMap = initResourceHashMap();	
	@Getter(lazy=true) private final Date startDate = initStartDate();
	@Getter(lazy=true) private final Date endDate = initEndDate();
	@Getter(lazy=true) private final Long numDescendants = initNumDescendants(); 
	@Getter(lazy=true) private final ArrayList<EnrichedTask> nonStartedFSPredecessorTasks = initNonStartedFSPredecessorTasks();

	// As
	@Getter private ArrayList<EnrichedDepend> enrichedDependsPredecessors = new ArrayList<EnrichedDepend>();


	public static void initializeSummary()
	{
		SUMMARISED_TASK_HASHMAP.clear();
	}


	public Long getCompleteLong()
	{
		return task.getCompleteLong();
	}
	public Long getDurationLong()
	{
		return task.getDurationLong();
	}
	public Boolean canSenderUpdateTask(Message message)
	{
		Boolean resultBoolean = true;

		// If the configuration is set, then only return true if email sender is in resource list
		if (UserConfig.getInstance().getUpdate().getAssigneesOnly())
		{
			String sender = "";
			try {
				sender = InternetAddress.toString(message.getReplyTo()).toLowerCase();
			} catch (MessagingException e) {
				LOGGER.error("ERROR checking if sender can reply for task: " + task.getId());
			}
			resultBoolean = false;
			for (Resource resource : getResources())
			{
				resultBoolean = sender.contains(resource.getContacts().toLowerCase()) ? true : resultBoolean;
			}
		}

		return resultBoolean;
	}

	public Boolean shouldTaskBeNotified()
	{		
		Boolean resultBoolean = true;

		// If the task has child tasks and no option is set to include parent tasks, then don't notify 
		resultBoolean = (!UserConfig.getInstance().getNotify().getIncludeParentTasks()
				&& getNumDescendants() > 0) ? false : resultBoolean ;
		
		// If the task has any predecessor tasks with Finish-To-Start relationship to this one that
		// has not started, and no option set to include such tasks, then again don't notify
		resultBoolean = (!UserConfig.getInstance().getNotify().getIncludeNonStartedFSPredecessors() 
				&& getNonStartedFSPredecessorTasks().size() > 0) ? false : resultBoolean;
		
		return resultBoolean;
	}
	public String summariseTask()
	{
		return summariseTask("");
	}
	public String summariseTask(String hdr)
	{
		String resultString = "";

		if (SUMMARISED_TASK_HASHMAP.get(getTask().getId()) == null)
		{
			SUMMARISED_TASK_HASHMAP.put(getTask().getId(), this);

			StringBuilder stringBuilder = new StringBuilder();

			stringBuilder.append(hdr
					+ "Id: " + getTask().getId()
					+ " Name: " + getTask().getName()
					+ " Start: " + getStartDate()
					+ " End: " + getEndDate()
					+ " Progress: " + getTask().getComplete() + "%"
					+ " Resource" + (getResources().size() != 1 ? "s: " : ": ") + getResourceEmails()
					);

			// Now show break down by composition
			if (getEnrichedDependsPredecessors().size() > 0)
			{
				stringBuilder.append(hdr
						+ " Predecessor" + (getEnrichedDependsPredecessors().size() > 1 ? "s" : "") + ": "
						);
				getEnrichedDependsPredecessors().forEach(d -> 
				{
					stringBuilder.append(
							"(Id:"	+ d.getSrcEnrichedTask().getTask().getId() 
							+ " Type:" + d.getDepend().getType()
							+ " Diff:" + d.getDepend().getDifference()
							+ " Hard:" + d.getDepend().getHardness()
							+ ") ");
				});

			}
			stringBuilder.append("\n");

			if (this.getNumDescendants() > 1L)
			{
				task.getTasks().forEach(t ->
				{
					EnrichedTask enrichedTask = Repository.getInstance().getEnrichedTaskHashMap().get(t.getId());
					stringBuilder.append(enrichedTask.summariseTask(hdr + "  "));
				});
			}			

			resultString = stringBuilder.toString();
		}

		return resultString;
	}
	private String getResourceEmails()
	{
		StringBuilder resLiStringBuilder = new StringBuilder();
		getResources().forEach(r -> 
		resLiStringBuilder.append(resLiStringBuilder.length() > 0 ? ", " : "" + r.getContacts()));
		return resLiStringBuilder.toString();
	}

	private ArrayList<Resource> initResources()
	{
		ArrayList<Resource> resultArrayList = new ArrayList<Resource>();

		// Find all the resources for this task from the Repository
		ArrayList<Allocation> allocations = Repository.getInstance().getAllocationTaskIdHashMap().get(task.getId());
		if (allocations != null)
		{
			allocations.forEach(a -> 
			{
				String resourceIdString = a.getResourceId();
				EnrichedResource enrichedResource = Repository.getInstance().getEnrichedResourceHashMap().get(resourceIdString);
				resultArrayList.add(enrichedResource.getResource());
			});
		}
		return resultArrayList;
	}

	private ArrayList<EnrichedDepend> initEnrichedDepends()
	{
		ArrayList<EnrichedDepend> resultArrayList = new ArrayList<EnrichedDepend>();

		ArrayList<Depend> arrayList = task.getDepends();
		if (arrayList != null)
		{
			arrayList.forEach(d ->
			{
				EnrichedDepend enrichedDepend = new EnrichedDepend(d, this);
				resultArrayList.add(enrichedDepend);

				// Add relationship the other way too..
				EnrichedTask enrichedTask = Repository.getInstance().getEnrichedTaskHashMap().get(d.getId());
				enrichedTask.getEnrichedDependsPredecessors().add(enrichedDepend);
			});
		}

		return resultArrayList;
	}

	private HashMap<String, Resource> initResourceHashMap()
	{
		HashMap<String, Resource> result = new HashMap<String, Resource>();
		getResources().forEach(r -> result.put(r.getId(), r));
		return result;
	}

	private Date initStartDate()
	{
		Date resultDate = null;

		try {
			resultDate = SD_DATE_FORMAT.parse(task.getStart());
		} catch (ParseException e) {
			LOGGER.error("ERROR Parsing Date: " + task.getStart() + " for task: " + task.getId());
		}

		return resultDate;
	}
	private Date initEndDate()
	{
		Date resultDate = AppUtils.addDaysToDate(getStartDate(), getDurationLong());
		return resultDate;
	}
	private Long initNumDescendants()
	{
		Long resultLong = 0L;

		if (getTask() != null)
		{
			resultLong = getNumDescendants(getTask());
		}

		return resultLong;
	}

	private Long getNumDescendants(Task t)
	{
		Long resultLong = 0L;
		if (t.getTasks() != null)
		{
			resultLong += t.getTasks().size();
			for (Task cTask : t.getTasks())
			{
				resultLong += getNumDescendants(cTask);
			}
		}
		return resultLong;
	}

	private ArrayList<EnrichedTask> initNonStartedFSPredecessorTasks()
	{
		ArrayList<EnrichedTask> result = new ArrayList<EnrichedTask>();

		addNonStartedFSPredecessorTasks(result);

		return result;
	}

	private void addNonStartedFSPredecessorTasks(ArrayList<EnrichedTask> list)
	{
		// Iterate through the predecessors

		getEnrichedDependsPredecessors().forEach(d -> 
		{
			EnrichedTask predecEnrichedTask = d.getSrcEnrichedTask();
			if (d.expectPredecessorComplete())
			{
				if (predecEnrichedTask.getTask().getCompleteLong() == 0)
				{
					list.add(predecEnrichedTask);
				}
			}
			predecEnrichedTask.addNonStartedFSPredecessorTasks(list);
		});

	}

}
