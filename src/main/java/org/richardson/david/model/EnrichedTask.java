/*
Copyright 2021 David Richardson, a regular GanttProject User

This file is part of GanttProjectAutomator, a utility conceived from
years of project management experience to make task status communication
just a little bit easier.

It works specifically with files generated by GanttProject, an 
open source project management tool.

GanttProjectAutomator is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

GanttProjectAutomator is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

See <http://www.gnu.org/licenses/>.
*/
package org.richardson.david.model;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;

import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.InternetAddress;

import org.richardson.david.config.UserConfig;
import org.richardson.david.entity.gantt.Allocation;
import org.richardson.david.entity.gantt.Resource;
import org.richardson.david.entity.gantt.Task;
import org.richardson.david.utils.AppUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public class EnrichedTask 
{
	private static Logger LOGGER = LoggerFactory.getLogger(EnrichedTask.class);
	private static final SimpleDateFormat SD_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");

	@NonNull private Task task;

	@Getter(lazy=true) private final ArrayList<Resource> resources = initResources();	
	@Getter(lazy=true) private final HashMap<String, Resource> resourceHashMap = initResourceHashMap();	
	@Getter(lazy=true) private final Date startDate = initStartDate();
	@Getter(lazy=true) private final Date endDate = initEndDate();
	@Getter(lazy=true) private final Long numDescendants = initNumDescendants(); 

	public Long getCompleteLong()
	{
		return task.getCompleteLong();
	}
	public Long getDurationLong()
	{
		return task.getDurationLong();
	}
	public Boolean canSenderUpdateTask(Message message)
	{
		Boolean resultBoolean = true;

		// If the configuration is set, then only return true if email sender is in resource list
		if (UserConfig.getInstance().getUpdate().getAssigneesOnly())
		{
			String sender = "";
			try {
				sender = InternetAddress.toString(message.getReplyTo()).toLowerCase();
			} catch (MessagingException e) {
				LOGGER.error("ERROR checking if sender can reply for task: " + task.getId());
			}
			resultBoolean = false;
			for (Resource resource : getResources())
			{
				resultBoolean = sender.contains(resource.getContacts().toLowerCase()) ? true : resultBoolean;
			}
		}

		return resultBoolean;
	}
	public String summariseTask()
	{
		StringBuilder stringBuilder = new StringBuilder();

		stringBuilder.append(""
				+ "Id: " + getTask().getId()
				+ " Name: " + getTask().getName()
				+ " Start: " + getStartDate()
				+ " End: " + getEndDate()
				+ " Progress: " + getTask().getComplete() + "%"
				+ " Resource" + (getResources().size() != 1 ? "s" : "") + getResourceEmails()
				);

		return stringBuilder.toString();
	}
	private String getResourceEmails()
	{
		StringBuilder resLiStringBuilder = new StringBuilder();
		getResources().forEach(r -> 
		resLiStringBuilder.append(resLiStringBuilder.length() > 0 ? ", " : "" + r.getContacts()));
		return resLiStringBuilder.toString();
	}

	private ArrayList<Resource> initResources()
	{
		ArrayList<Resource> resultArrayList = new ArrayList<Resource>();

		// Find all the resources for this task from the Repository
		ArrayList<Allocation> allocations = Repository.getInstance().getAllocationTaskIdHashMap().get(task.getId());
		if (allocations != null)
		{
			allocations.forEach(a -> 
			{
				String resourceIdString = a.getResourceId();
				EnrichedResource enrichedResource = Repository.getInstance().getEnrichedResourceHashMap().get(resourceIdString);
				resultArrayList.add(enrichedResource.getResource());
			});
		}
		return resultArrayList;
	}
	
	private HashMap<String, Resource> initResourceHashMap()
	{
		HashMap<String, Resource> result = new HashMap<String, Resource>();
		getResources().forEach(r -> result.put(r.getId(), r));
		return result;
	}
	
	private Date initStartDate()
	{
		Date resultDate = null;

		try {
			resultDate = SD_DATE_FORMAT.parse(task.getStart());
		} catch (ParseException e) {
			LOGGER.error("ERROR Parsing Date: " + task.getStart() + " for task: " + task.getId());
		}

		return resultDate;
	}
	private Date initEndDate()
	{
		Date resultDate = AppUtils.addDaysToDate(getStartDate(), getDurationLong());
		return resultDate;
	}
	private Long initNumDescendants()
	{
		Long resultLong = 0L;

		if (getTask() != null)
		{
			resultLong = getNumDescendants(getTask());
		}

		return resultLong;
	}

	private Long getNumDescendants(Task t)
	{
		Long resultLong = 0L;
		if (t.getTasks() != null)
		{
			resultLong += t.getTasks().size();
			for (Task cTask : t.getTasks())
			{
				resultLong += getNumDescendants(cTask);
			}
		}
		return resultLong;
	}
}
