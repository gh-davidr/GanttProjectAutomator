/*
Copyright 2021 David Richardson, a regular GanttProject User

This file is part of GanttProjectAutomator, a utility conceived from
years of project management experience to make task status communication
just a little bit easier.

It works specifically with files generated by GanttProject, an 
open source project management tool.

GanttProjectAutomator is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

GanttProjectAutomator is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

See <http://www.gnu.org/licenses/>.
*/
package org.richardson.david.load;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.richardson.david.config.UserConfig;
import org.richardson.david.entity.gantt.Project;
import org.richardson.david.utils.AppUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;

import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.Marshaller;
import lombok.Getter;
import lombok.Value;

@Value
public class DataSaver {
	private static Logger LOGGER = LoggerFactory.getLogger(DataSaver.class);

	private DataLoader dataLoader;
	@Getter(lazy=true) private String     backupFileName = initBackupFileName();

	public void backupFile()
	{
		marshalXMLToFile(getBackupFileName());
	}

	public void updateFile()
	{
		marshalXMLToFile(dataLoader.getFileNameString());
	}

	public void deleteBackup()
	{
		deleteFile(getBackupFileName());
	}

	private String makeBackupFilename(String path, String extn)
	{
		String result = new String(path);
		String fExtnString = extn.contains(".") ? extn : "." + extn;
		result = result.replace(fExtnString, "_" + AppUtils.getCurrentTime() + fExtnString);
		return result;
	}

	private String initBackupFileName()
	{
		File f = new File(dataLoader.getFileNameString());
		String pathString = UserConfig.getInstance().getUpdate().getBackups() 
				+ System.getProperty("file.separator")
				+ f.getName();

		String resultString = makeBackupFilename(pathString, ".gan");
		return resultString;
	}

	private void marshalXMLToFile(String fnameString)
	{
		try {
			JAXBContext jaxbContext = JAXBContext.newInstance(Project.class);
			Marshaller marshaller = jaxbContext.createMarshaller();

			DocumentBuilderFactory docBuilderFactory =
					DocumentBuilderFactory.newInstance();
			Document document =
					docBuilderFactory.newDocumentBuilder().newDocument();
			
			// Marshall the feed object into the empty document.
			marshaller.marshal(dataLoader.getProject(), document);
			
			// https://javacoalface.blogspot.com/2012/09/outputting-cdata-sections-with-jaxb.html
			
			// Transform the DOM to the output stream
			// TransformerFactory is not thread-safe
			TransformerFactory transformerFactory =
			    TransformerFactory.newInstance();
			Transformer nullTransformer = transformerFactory.newTransformer();
			nullTransformer.setOutputProperty(OutputKeys.INDENT, "yes");
			
			// Not great, but any element with these names is output as a CDATA
			nullTransformer.setOutputProperty(OutputKeys.CDATA_SECTION_ELEMENTS, "description notes");
			FileOutputStream fileOutputStream = new FileOutputStream(fnameString);
			nullTransformer.transform(new DOMSource(document),
			     new StreamResult(fileOutputStream));
		
			fileOutputStream.close();
		}
		catch (Exception e)
		{
			LOGGER.error("Unable to create backup XML model file to path: " + fnameString + " " + e.toString());
		}
	}

	public void deleteFile(String filename)
	{
		try 
		{
			Files.delete(Paths.get(filename));
		}
		catch (IOException e)
		{
			LOGGER.error("Unable to delete file: " + filename + " " + e.toString());
		}
	}

}
