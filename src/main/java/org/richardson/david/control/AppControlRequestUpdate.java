/*
Copyright 2021 David Richardson, a regular GanttProject User

This file is part of GanttProjectAutomator, a utility conceived from
years of project management experience to make task status communication
just a little bit easier.

It works specifically with files generated by GanttProject, an 
open source project management tool.

GanttProjectAutomator is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

GanttProjectAutomator is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

See <http://www.gnu.org/licenses/>.
*/
package org.richardson.david.control;

import javax.mail.Message;
import javax.mail.internet.InternetAddress;

import org.richardson.david.config.UserConfig;
import org.richardson.david.entity.email.EmailInbox;
import org.richardson.david.entity.email.EmailMessageInboxPlaceholderUpdate;
import org.richardson.david.entity.email.EmailMessageResponseAck;
import org.richardson.david.entity.email.EmailMessageAlertUpdate;
import org.richardson.david.entity.email.EmailMessageInboxPlaceholderAll;
import org.richardson.david.entity.email.EmailMessageInboxPlaceholderBase;
import org.richardson.david.entity.email.ReadEmailSession;
import org.richardson.david.entity.email.TaskStartEmailResponseParser;
import org.richardson.david.load.DataSaver;
import org.richardson.david.model.EnrichedTask;
import org.richardson.david.model.Repository;
import org.richardson.david.utils.AppUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public class AppControlRequestUpdate extends AppControlBase {

	private static Logger LOGGER = LoggerFactory.getLogger(AppControlRequestUpdate.class);

	@NonNull private final DataSaver  dataSaver;
	@NonNull private final Boolean    reportOnlyBoolean;

	public void doUpdate()
	{
		doUpdate(true);	
	}

	public int doUpdate(Boolean log)
	{
		return doUpdate(log, new EmailMessageInboxPlaceholderUpdate());	
	}
	
	public int doUpdate(Boolean log, EmailMessageInboxPlaceholderBase inboxMonitorPlaceholderEmail)
	{
		return doUpdate(new ReadEmailSession(
				EmailMessageInboxPlaceholderBase.addTag(
						new EmailMessageInboxPlaceholderUpdate().getInboxMonitorString(), 
						new EmailMessageInboxPlaceholderAll().getInboxMonitorString())),
				log,
				inboxMonitorPlaceholderEmail);	
	}
	
	private int doUpdate(ReadEmailSession accountEmails, Boolean log, EmailMessageInboxPlaceholderBase inboxMonitorPlaceholderEmail)
	{
		// 1 Read inbox down to special email
		// 2 Identify all emails with our signature
		// 3 Handle all emails updating tasks based on response back
		// 4 Add special email that denotes how far to read down to next time

		int tasksUpdated = 0;
		int alertsRaised = 0;

		getDataSaver().backupFile();

		for (Message message : accountEmails.getFolderEmails().getOrderedMessages())
		{
			try {
				//				accountEmails.getFolderEmails();
				String subject = message.getSubject();
				String bodyString = EmailInbox.getTextFromMessage(message);
				String sender = AppUtils.justTheEmailAddress(InternetAddress.toString(message.getReplyTo()).toLowerCase());
				//				EnrichedTask task = Repository.getInstance().findEnrichedTaskFromEmail(bodyString);

				EnrichedTask task = getEnrichedTaskForMessage(message);

				if ( (task != null)
						&& (UserConfig.getInstance().getUpdate().getIncludeParentTasks()
								|| task.getNumDescendants() == 0))
				{
					if (task.canSenderUpdateTask(message))
					{
						if (reportOnlyBoolean)
						{
							LOGGER.info("  " + getRunMode() + "Task authorized to be actioned with an update: " + task.summariseTask());
						}
						else 
						{
							TaskStartEmailResponseParser responseEmailParser = new TaskStartEmailResponseParser(bodyString, task);
							tasksUpdated += responseEmailParser.getTaskUpdated() ? 1 : 0;

							if (responseEmailParser.getTaskUpdated())
							{
								EmailMessageResponseAck acknowledgeEmail = new EmailMessageResponseAck(message, task);
								acknowledgeEmail.sendAcknowledgeEmail();
							}
						}
					}
					else
					{
						if (reportOnlyBoolean)
						{
							LOGGER.info("  " + getRunMode() + "Task NOT AUTHORIZED to be actioned with an update: " + task.summariseTask());
						}
						else 
						{
							EmailMessageAlertUpdate alertEmail = new EmailMessageAlertUpdate(message, task);
							alertEmail.sendAlertEmail();
							alertsRaised++;
						}
					}
				}

				// Alert if ...
				//  1 message is intended for this project
				//  2 message does not have structure of a reminder
				//  3 message does include task reference

				else if (Repository.getInstance().messageForThisProject(bodyString) 
						&& !Repository.getInstance().messageIsARemind(subject)
						&& Repository.getInstance().messageReferencesATask(bodyString))				
				{
					LOGGER.error(getRunMode() + "Unable to identify task from email.  " + sender + ", Subject '" + subject + "'");
				}
			} catch (Exception e) {
				LOGGER.error(getRunMode() + "Error handling email responses\n" + e.toString());
			}		
		}

		// Put a placeholder email in the list so we don't reprocess task request emails
		// either as valid updates or invalid with alerts raised.
		if (tasksUpdated + alertsRaised > 0 && inboxMonitorPlaceholderEmail != null)
		{
			inboxMonitorPlaceholderEmail.sendMonitorPlaceholderEmail();			
		}

		if (tasksUpdated > 0)
		{
			getDataSaver().updateFile();
		}
		else
		{
			getDataSaver().deleteBackup();
		}

		if (log)
		{
			if (tasksUpdated + alertsRaised > 0)
			{
				LOGGER.info(getRunMode() + AppVersion.getAppNameString() + "-" + AppVersion.getVersionString());
			}

			if (reportOnlyBoolean)
			{
				LOGGER.info(getRunMode() + "Updates complete.  Report Only Mode active, so no updates actually performed.");
			}
			else 
			{
				LOGGER.info(getRunMode() + "Updates complete.  " 
						+ tasksUpdated + " task" + (tasksUpdated == 1 ? "" : "s") + " processed & updated on the plan."
						);
			}
		}

		return tasksUpdated + alertsRaised;
	}


	public EnrichedTask getEnrichedTaskForMessage(Message message)
	{
		EnrichedTask result = null;

		try {			
			String bodyString = EmailInbox.getTextFromMessage(message);
			result = Repository.getInstance().findEnrichedTaskFromEmail(bodyString);
		}
		catch (Exception e) {
			LOGGER.error(getRunMode() + "Error handling email responses\n" + e.toString());

		}
		return result;
	} 

}
