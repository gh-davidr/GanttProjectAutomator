/*
Copyright 2021 David Richardson, a regular GanttProject User

This file is part of GanttProjectAutomator, a utility conceived from
years of project management experience to make task status communication
just a little bit easier.

It works specifically with files generated by GanttProject, an 
open source project management tool.

GanttProjectAutomator is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

GanttProjectAutomator is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

See <http://www.gnu.org/licenses/>.
*/
package org.richardson.david.entity.email;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;

import javax.mail.BodyPart;
import javax.mail.Folder;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.ContentType;
import javax.mail.internet.MimeMultipart;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.safety.Safelist;
import org.richardson.david.config.UserConfig;
import org.richardson.david.model.Repository;
import org.richardson.david.utils.AppUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Value;

@Value
@AllArgsConstructor
public class EmailInbox 
{
	private static Logger LOGGER = LoggerFactory.getLogger(EmailInbox.class);
	private Folder    folder;
	private String    folderName;
	private Message[] messages;
	private String    inboxMonitorString;

	@Getter(lazy=true) private ArrayList<Message> orderedMessages = initOrderedMessages();

	private ArrayList<Message> initOrderedMessages()
	{
		ArrayList<Message> resultArrayList = new ArrayList<Message>();

		UserConfig config = UserConfig.getInstance();
		String emailSignatureString = config.getCommon().getEmailSignature();
		Long minsBack = config.getNotify().getMinsBack();
		Date rcvdSinceDate = AppUtils.addMinsToDate(new Date(), -minsBack);

		int messgCount = messages.length;

		Boolean keepAddingBoolean = true;
		Boolean seenRecentMonitorEmailBoolean = false;

		for (int i = messgCount - 1; keepAddingBoolean && i >= 0; i--)
		{
			Message message = messages[i];
			try {
				//				String bodyString = getBody((Part) message);
				String bodyString = getTextFromMessage(message);
				String subjectString = message.getSubject();
				Boolean hasMonitorTagBoolean = EmailMessageInboxPlaceholderBase.bodyContainsTagList(bodyString, inboxMonitorString);

				Boolean monitorEmailBoolean = hasMonitorTagBoolean // bodyString.contains(inboxMonitorString)
						&& bodyString.contains(EmailMessageInboxPlaceholderBase.getEMAIL_PROJECT_TAG())
						&& bodyString.contains(Repository.getInstance().getProject().getName());
				seenRecentMonitorEmailBoolean = monitorEmailBoolean ? monitorEmailBoolean : seenRecentMonitorEmailBoolean;
				keepAddingBoolean = message.getReceivedDate().compareTo(rcvdSinceDate) > 0 && !seenRecentMonitorEmailBoolean;
				if (keepAddingBoolean 

						// The message is a response to an automated notification for this project
						// which has a custom signature unique to this project.
						//
						// Or, it's a plea for help!
						// Or, it's a plea for notifications!
						&& (bodyString.contains(emailSignatureString)
								|| Repository.getInstance().messageIsAPleaForHelp(subjectString)
								|| Repository.getInstance().messageIsAPleaForNotifications(subjectString)
								|| Repository.getInstance().messageIsAPleaForSummarise(subjectString))

						// This filters out the automated placeholders from being treated like update messages
						&& !bodyString.contains(EmailMessageInboxPlaceholderBase.getEMAIL_MONITOR_TAG()))
				{
					resultArrayList.add(message);
				}

			} catch (MessagingException e) {
				LOGGER.error("Error ordering messages and getting receiveddate\n" + e.toString());
				keepAddingBoolean = false;
			} catch (IOException e) {
				LOGGER.error("Error ordering messages and getting message body\n" + e.toString());
				keepAddingBoolean = false;
			}
		}

		return resultArrayList;
	}


	public static String getTextFromMessage(Message message) throws IOException, MessagingException {
		return getTextFromMessage(message, true);
	}

	public static String getTextFromMessage(Message message, Boolean plainText) throws IOException, MessagingException {
		String result = "";
		if (message.isMimeType("text/plain")) {
			result = message.getContent().toString();
		}
		else if (message.isMimeType("text/html")) {
			String html = (String) message.getContent();
			result = EmailInbox.parseHtml(html);
			//			result = org.jsoup.Jsoup.parse(html).text();
		} else if (message.isMimeType("multipart/*")) {
			MimeMultipart mimeMultipart = (MimeMultipart) message.getContent();
			result = EmailInbox.getTextFromMimeMultipart(mimeMultipart, plainText);
		}
		return result;
	}

	private static String getTextFromMimeMultipart(
			MimeMultipart mimeMultipart, Boolean plainText) throws IOException, MessagingException {

		int count = mimeMultipart.getCount();
		if (count == 0)
			throw new MessagingException("Multipart with no body parts not supported.");
		boolean multipartAlt = new ContentType(mimeMultipart.getContentType()).match("multipart/alternative");
		if (multipartAlt)
			// alternatives appear in an order of increasing 
			// faithfulness to the original content. Customize as req'd.
			return EmailInbox.getTextFromBodyPart(mimeMultipart.getBodyPart(count - 1), plainText);
		String result = "";
		for (int i = 0; i < count; i++) {
			BodyPart bodyPart = mimeMultipart.getBodyPart(i);
			result += EmailInbox.getTextFromBodyPart(bodyPart, plainText);
		}
		return result;
	}

	private static String getTextFromBodyPart(
			BodyPart bodyPart, Boolean plainText) throws IOException, MessagingException {

		String result = "";
		if (bodyPart.isMimeType("text/plain")) {
			result = (String) bodyPart.getContent();
		} else if (bodyPart.isMimeType("text/html")) {
			String html = (String) bodyPart.getContent();
			if (plainText)
			{	
				result = EmailInbox.parseHtml(html);
			}
			else
			{
				result = html;
			}
		} else if (bodyPart.getContent() instanceof MimeMultipart){
			result = EmailInbox.getTextFromMimeMultipart((MimeMultipart)bodyPart.getContent(), plainText);
		}
		return result;
	}

	private static String parseHtml(String htmlString)
	{
		String result = "";

		// David
		// https://www.baeldung.com/jsoup-line-breaks
		Document jsoupDoc = Jsoup.parse(htmlString);
		Document.OutputSettings outputSettings = new Document.OutputSettings();
		outputSettings.prettyPrint(false);
		jsoupDoc.outputSettings(outputSettings);
		jsoupDoc.select("br").before("\\n");
		jsoupDoc.select("p").before("\\n"); 

		String str = jsoupDoc.html().replaceAll("\\\\n", "\n");
		result = Jsoup.clean(str, "", Safelist.none(), outputSettings);

		return result;
	}
}
